// PDF.Document Tests.swift

import Foundation
import Testing
@testable import PDF_Standard

@Suite
struct `PDF.Document Tests` {

    // MARK: - Single Page Construction

    @Test
    func `Creates single page document`() {
        let page = PDF.Page(paperSize: .letter, content: PDF.Content())
        let doc = PDF.Document(page: page)

        #expect(doc.pages.count == 1)
        #expect(doc.info == nil)
    }

    @Test
    func `Creates document with info`() {
        let page = PDF.Page(paperSize: .letter, content: PDF.Content())
        let info = PDF.Info(title: "Test", author: "Swift")
        let doc = PDF.Document(page: page, info: info)

        #expect(doc.info?.title == "Test")
        #expect(doc.info?.author == "Swift")
    }

    // MARK: - Multi-Page Construction

    @Test
    func `Creates multi-page document`() {
        let pages = [
            PDF.Page(paperSize: .letter, content: PDF.Content()),
            PDF.Page(paperSize: .a4, content: PDF.Content()),
            PDF.Page(paperSize: .legal, content: PDF.Content())
        ]
        let doc = PDF.Document(pages: pages)

        #expect(doc.pages.count == 3)
    }

    // MARK: - Builder Syntax

    @Test
    func `Creates document with builder syntax`() {
        let doc = PDF.Document(title: "My Doc", author: "Me") {
            PDF.Page(paperSize: .letter) {
                PDF.Content.text("Hello", at: PDF.Point(x: 72, y: 72))
            }
        }

        #expect(doc.pages.count == 1)
        #expect(doc.info?.title == "My Doc")
        #expect(doc.info?.author == "Me")
    }

    @Test
    func `Builder with no metadata has nil info`() {
        let doc = PDF.Document {
            PDF.Page(paperSize: .letter, content: PDF.Content())
        }

        #expect(doc.info == nil)
    }

    @Test
    func `Builder with multiple pages`() {
        let doc = PDF.Document {
            PDF.Page(paperSize: .letter, content: PDF.Content())
            PDF.Page(paperSize: .a4, content: PDF.Content())
        }

        #expect(doc.pages.count == 2)
    }

    // MARK: - Version

    @Test
    func `Default version is 1.7`() {
        let doc = PDF.Document(page: PDF.Page(paperSize: .letter, content: PDF.Content()))
        #expect(doc.version == .v1_7)
    }

    // MARK: - Serialization

    @Test
    func `Serializes to bytes`() {
        let doc = PDF.Document(page: PDF.Page(paperSize: .letter, content: PDF.Content()))
        let bytes = [UInt8](doc)

        #expect(bytes.count > 0)

        let header = String(decoding: bytes.prefix(8), as: UTF8.self)
        #expect(header == "%PDF-1.7")
    }

    @Test
    func `Compression applies FlateDecode filter for large content`() {
        // Need enough content for compression to be beneficial (ZLIB has ~6 byte overhead)
        let doc = PDF.Document {
            PDF.Page(paperSize: .letter) {
                PDF.Content.text("Line 1: The quick brown fox jumps over the lazy dog.", at: PDF.Point(x: 72, y: 72))
                PDF.Content.text("Line 2: Pack my box with five dozen liquor jugs.", at: PDF.Point(x: 72, y: 90))
                PDF.Content.text("Line 3: How vexingly quick daft zebras jump!", at: PDF.Point(x: 72, y: 108))
                PDF.Content.text("Line 4: The five boxing wizards jump quickly.", at: PDF.Point(x: 72, y: 126))
                PDF.Content.text("Line 5: Sphinx of black quartz, judge my vow.", at: PDF.Point(x: 72, y: 144))
            }
        }

        let compressed = [UInt8](doc, compress: true)
        let uncompressed = [UInt8](doc, compress: false)

        let compressedStr = String(decoding: compressed, as: UTF8.self)
        let uncompressedStr = String(decoding: uncompressed, as: UTF8.self)

        // Compressed output should have FlateDecode filter
        #expect(compressedStr.contains("/Filter /FlateDecode"))
        // Uncompressed output should not
        #expect(!uncompressedStr.contains("/Filter /FlateDecode"))
        // Compressed should be smaller
        #expect(compressed.count < uncompressed.count)
    }

    @Test
    func `Outputs simple PDF for inspection`() throws {
        let doc = PDF.Document(title: "PDF Standard Test") {
            PDF.Page(paperSize: .letter) {
                PDF.Content.text(
                    "PDF Standard Test Document",
                    at: PDF.Point(x: 72, y: 72),
                    font: .helveticaBold,
                    size: 24
                )
                PDF.Content.text(
                    "Generated by swift-pdf-standard",
                    at: PDF.Point(x: 72, y: 100),
                    font: .helvetica,
                    size: 12
                )
            }
        }

        let bytes = [UInt8](doc)
        let path = try PDFOutput.write(bytes, name: "pdf-standard-simple")

        #expect(bytes.count > 0)
        print("PDF written to: \(path)")
    }
}

// MARK: - PDF.Info Tests

@Suite
struct `PDF.Info Tests` {

    @Test
    func `Creates info with all fields`() {
        let info = PDF.Info(
            title: "Title",
            author: "Author",
            subject: "Subject",
            keywords: "key1, key2",
            creator: "Creator",
            producer: "Producer"
        )

        #expect(info.title == "Title")
        #expect(info.author == "Author")
        #expect(info.subject == "Subject")
        #expect(info.keywords == "key1, key2")
        #expect(info.creator == "Creator")
        #expect(info.producer == "Producer")
    }

    @Test
    func `Creates info with partial fields`() {
        let info = PDF.Info(title: "Only Title")

        #expect(info.title == "Only Title")
        #expect(info.author == nil)
        #expect(info.subject == nil)
    }

    @Test
    func `Converts to ISO info`() {
        let info = PDF.Info(title: "Test", author: "Swift")
        let isoInfo = info.isoInfo

        #expect(isoInfo.title == "Test")
        #expect(isoInfo.author == "Swift")
    }
}
